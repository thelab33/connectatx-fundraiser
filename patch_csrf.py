#!/usr/bin/env python3
"""
FundChamps CSRF Auto-Patcher
- Adds csrf_field macro
- Injects CSRF hidden input into POST forms missing it
- Adds meta[name=csrf-token] and a fetch() CSRF wrapper to base.html
- Optionally adds Axios interceptor
- Reports blanket csrf.exempt(api_bp) occurrences

Idempotent + safe backups.
"""

import argparse, datetime, os, re, sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent
TEMPLATES_DIR = ROOT / "app" / "templates"
PARTIALS_DIR = TEMPLATES_DIR / "partials"
FORMS_MACRO = PARTIALS_DIR / "forms.html"
BASE_HTML = TEMPLATES_DIR / "base.html"
APP_JS = ROOT / "app" / "static" / "js" / "app.js"

BACKUP_TS = datetime.datetime.now().strftime("%Y%m%d%H%M%S")

# --- content blocks (kept minimal & safe) ---

MACRO_CONTENT = """{# Auto-generated by patch_csrf.py #}
{% macro csrf_field() -%}
  <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
{%- endmacro %}
"""

META_TAG_RE = re.compile(r'<meta\s+name=["\']csrf-token["\']', re.I)

FETCH_WRAPPER_SNIPPET = """<script>
/* Auto-injected by patch_csrf.py */
(function(){
  try {
    var meta = document.querySelector('meta[name="csrf-token"]');
    var fromMeta = meta ? meta.getAttribute('content') : null;
    var fromCookie = (document.cookie.split('; ').find(function(r){return r.indexOf('csrf_token=')===0;})||'').split('=')[1] || null;
    window.csrfToken = fromMeta || fromCookie || '';
    if (!window.__fcFetchWrapped) {
      var _fetch = window.fetch;
      window.fetch = function(input, init){ init = init || {};
        try {
          var url = (typeof input === 'string') ? input : (input && input.url) || '';
          var method = ((init.method || 'GET')+'').toUpperCase();
          var sameOrigin = !/^https?:\\/\\//i.test(url) || url.indexOf(location.origin)===0;
          if (sameOrigin && ['POST','PUT','PATCH','DELETE'].indexOf(method) !== -1) {
            init.headers = Object.assign({}, init.headers || {}, {'X-CSRFToken': window.csrfToken || ''});
            if (!init.credentials) init.credentials = 'same-origin';
          }
        } catch(e) {}
        return _fetch(input, init);
      };
      window.__fcFetchWrapped = true;
    }
  } catch(e) {}
})();
</script>"""

AXIOS_INTERCEPTOR = """
/* Auto-injected by patch_csrf.py */
if (typeof axios !== 'undefined' && !window.__fcAxiosPatched) {
  axios.interceptors.request.use(function(config){
    if (!config) config = {};
    if (!config.headers) config.headers = {};
    var t = (typeof window !== 'undefined' && window.csrfToken) ? window.csrfToken : '';
    if (t) config.headers['X-CSRFToken'] = t;
    if (config.withCredentials == null) config.withCredentials = true;
    return config;
  });
  window.__fcAxiosPatched = true;
}
"""

# Heuristics to detect a CSRF field inside a form
HAS_CSRF_TOKEN_RE = re.compile(
    r'(name=["\']csrf_token["\']|{{\s*form\.csrf_token\s*}}|{{\s*form\.hidden_tag\(\)\s*}}|{{\s*csrf_token\(\)\s*}})',
    re.I
)

# Find POST forms; robust to attributes and whitespace; non-greedy to first '>'
FORM_OPEN_RE = re.compile(
    r'(<form\b[^>]*\bmethod\s*=\s*["\']?post["\']?[^>]*>)',
    re.I
)

# Where to import the macro (once per template)
IMPORT_MACRO_LINE = '{% from "partials/forms.html" import csrf_field %}'

# Inserted immediately after <form ...> if missing CSRF field
INSERT_CSRF_CALL = "\n  {{ csrf_field() }}\n"

def backup_file(path: Path):
    bak = path.with_suffix(path.suffix + f".bak.{BACKUP_TS}")
    bak.write_bytes(path.read_bytes())
    return bak

def ensure_forms_macro(dry_run=False):
    PARTIALS_DIR.mkdir(parents=True, exist_ok=True)
    if FORMS_MACRO.exists():
        existing = FORMS_MACRO.read_text(encoding="utf-8", errors="ignore")
        if "macro csrf_field" in existing:
            return False, "forms.html exists (macro present)"
    if dry_run:
        return True, f"[DRY] would create {FORMS_MACRO}"
    FORMS_MACRO.write_text(MACRO_CONTENT, encoding="utf-8")
    return True, f"created {FORMS_MACRO}"

def patch_base_html(dry_run=False):
    changed = False
    if not BASE_HTML.exists():
        return False, "base.html not found ‚Äî skipped"

    html = BASE_HTML.read_text(encoding="utf-8", errors="ignore")
    orig = html

    # Ensure meta[name=csrf-token] inside <head>
    head_open = re.search(r"<head[^>]*>", html, re.I)
    if head_open and not META_TAG_RE.search(html):
        insert_at = head_open.end()
        html = html[:insert_at] + '\n  <meta name="csrf-token" content="{{ csrf_token() }}">\n' + html[insert_at:]
        changed = True

    # Ensure fetch wrapper before </body>
    if "window.__fcFetchWrapped" not in html:
        body_close = html.lower().rfind("</body>")
        if body_close != -1:
            html = html[:body_close] + "\n" + FETCH_WRAPPER_SNIPPET + "\n" + html[body_close:]
            changed = True

    if changed and not dry_run:
        backup_file(BASE_HTML)
        BASE_HTML.write_text(html, encoding="utf-8")
        return True, f"patched {BASE_HTML}"
    elif changed:
        return True, f"[DRY] would patch {BASE_HTML}"
    else:
        return False, "base.html already has meta + fetch wrapper"

def patch_ax_ios(dry_run=False):
    if not APP_JS.exists():
        return False, "app/static/js/app.js not found ‚Äî skipped"
    js = APP_JS.read_text(encoding="utf-8", errors="ignore")
    if "window.__fcAxiosPatched" in js:
        return False, "Axios interceptor already present"
    if dry_run:
        return True, f"[DRY] would append Axios interceptor to {APP_JS}"
    backup_file(APP_JS)
    APP_JS.write_text(js.rstrip() + "\n" + AXIOS_INTERCEPTOR, encoding="utf-8")
    return True, f"appended Axios interceptor to {APP_JS}"

def needs_csrf_injection(form_block: str) -> bool:
    # form_block starts at <form ...>
    # If the form opening + first ~400 chars already contain a CSRF hint, skip
    head = form_block[:400]
    if HAS_CSRF_TOKEN_RE.search(head):
        return False
    return True

def import_macro_once(template_text: str) -> str:
    # Add import after any extends block; otherwise at very top.
    if IMPORT_MACRO_LINE in template_text:
        return template_text
    # place after first {% extends ... %} or at top
    lines = template_text.splitlines()
    inserted = False
    for i, line in enumerate(lines):
        if re.search(r'{%\s*extends\b', line):
            lines.insert(i+1, IMPORT_MACRO_LINE)
            inserted = True
            break
    if not inserted:
        lines.insert(0, IMPORT_MACRO_LINE)
    return "\n".join(lines)

def patch_forms_in_template(path: Path, dry_run=False):
    text = path.read_text(encoding="utf-8", errors="ignore")
    orig = text
    changes = 0

    # Scan for <form method=POST ...>
    for m in list(FORM_OPEN_RE.finditer(text)):
        start, end = m.span(1)
        # Look ahead small window to avoid scanning full file (inject immediately after >)
        after = text[end:end+500]
        sample = text[start:end] + after
        if needs_csrf_injection(sample):
            # inject after the '>' of <form ...>
            text = text[:end] + INSERT_CSRF_CALL + text[end:]
            changes += 1

    if changes > 0:
        # ensure macro import exists
        text2 = import_macro_once(text)
        if dry_run:
            return True, f"[DRY] {path} ‚Üí inject {changes} form(s)" + (" + add macro import" if text2 != text else "")
        backup_file(path)
        path.write_text(text2, encoding="utf-8")
        return True, f"{path} ‚Üí injected {changes} form(s)" + (" + added macro import" if text2 != text else "")
    else:
        return False, f"{path} unchanged (no missing CSRF on POST forms)"

def scan_and_patch_templates(dry_run=False):
    if not TEMPLATES_DIR.exists():
        return [], "templates dir not found"
    modified = []
    for p in TEMPLATES_DIR.rglob("*.html"):
        # Skip macro file we manage
        if p == FORMS_MACRO:
            continue
        # Only patch if it contains a POST form or looks like a form holder
        txt = p.read_text(encoding="utf-8", errors="ignore")
        if re.search(r'<form\b[^>]*\bmethod\s*=\s*["\']?post["\']?', txt, re.I):
            changed, msg = patch_forms_in_template(p, dry_run=dry_run)
            if changed: modified.append(str(p))
            print(msg)
    return modified, f"processed {len(list(TEMPLATES_DIR.rglob('*.html')))} templates"

def report_api_exemptions():
    found = []
    for p in (ROOT / "app").rglob("*.py"):
        txt = p.read_text(encoding="utf-8", errors="ignore")
        if re.search(r'\bcsrf\.exempt\(\s*api_bp', txt):
            found.append(str(p))
    return found

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--dry-run", action="store_true", help="Do not write changes, only report")
    ap.add_argument("--add-axios", action="store_true", help="Append axios interceptor if app/static/js/app.js exists")
    args = ap.parse_args()

    print("üîß FundChamps CSRF Auto-Patcher\n")
    if args.dry_run:
        print("MODE: DRY RUN ‚Äî no files will be written.\n")

    # 1) forms macro
    created, msg = ensure_forms_macro(dry_run=args.dry_run)
    print("‚Ä¢", msg)

    # 2) base.html
    changed, msg = patch_base_html(dry_run=args.dry_run)
    print("‚Ä¢", msg)

    # 3) templates pass
    mods, summary = scan_and_patch_templates(dry_run=args.dry_run)
    print("‚Ä¢", summary)

    # 4) axios (optional)
    if args.add_axios:
        ch, msg = patch_ax_ios(dry_run=args.dry_run)
        print("‚Ä¢", msg)

    # 5) report api exemptions
    offenders = report_api_exemptions()
    if offenders:
        print("\n‚ö†Ô∏è Detected blanket `csrf.exempt(api_bp)` in:")
        for f in offenders:
            print("   -", f)
        print("   üëâ Recommend narrowing to specific endpoints instead of the entire blueprint.")
    else:
        print("\n‚úÖ No blanket `csrf.exempt(api_bp)` found (or already narrowed).")

    print("\nDone. Backups (when writing) are saved as *.bak.%s" % BACKUP_TS)

if __name__ == "__main__":
    sys.exit(main())

