<style>
/* SaaS Pro Section Polish */
.fcx-section, .fcx-section--hero, .fcx-section--tiers {
  max-width: 1100px;
  margin-inline: auto;
  margin-bottom: 3rem;
  padding-inline: clamp(14px, 5vw, 36px);
}
</style>
<h2 class="sr-only">Sticky Cta Manager</h2>
{% set NONCE = NONCE if NONCE is defined else (csp_nonce() if csp_nonce is defined else '') %}
<section data-ui=""${name//_/ -}"" class="block">
{# ================= Sticky CTA Manager — reserves space + prevents overlap (Elite) ================= #}
<div id="fc-sticky-reserve" aria-hidden="true" style="height:0"></div>

<style nonce="{{ NONCE }}">
  :root{
    --fc-sticky-h: 0px;              /* reserved height for bottom-most CTA */
    --fc-sticky-gap: 8px;            /* vertical gap between stacked CTAs */
    --fc-safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  /* Reserve bottom padding so content doesn't sit under fixed CTAs */
  main, #main { padding-bottom: calc(var(--fc-sticky-h, 0px) + var(--fc-safe-bottom)); }
  /* Utility: fade when hidden */
  .fc-sticky-hide{ opacity:0 !important; pointer-events:none !important; transform: translateY(6px); }
  /* Mark when manager is controlling an element */
  [data-sticky-cta].fc-sticky-managed{ will-change: bottom, transform; transition: transform .18s ease; }
  @media (prefers-reduced-motion: reduce){
    [data-sticky-cta].fc-sticky-managed{ transition: none !important; }
  }
</style>

{% if script_open is defined %}{{ script_open() }}{% else %}<script nonce="{{ NONCE }}">{% endif %}
(() => {
  if (window.__fcStickyMgr) return; window.__fcStickyMgr = true;

  const RESERVE  = document.getElementById('fc-sticky-reserve');
  const SEL      = '[data-sticky-cta]';
  const GAP_PX   = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fc-sticky-gap')) || 8;

  /* ---------- helpers ---------- */
  const isVisible = (el) => {
    if (!el || el.hidden) return false;
    const cs = getComputedStyle(el);
    if (cs.position !== 'fixed' || cs.display === 'none' || cs.visibility === 'hidden') return false;
    if (el.offsetParent === null) return false;
    return cs.bottom !== 'auto'; // we only stack bottom-anchored CTAs
  };

  const px = (v) => `${Math.max(0, Math.round(Number(v) || 0))}px`;

  // Get the element's *baseline* bottom (px) before stacking; cache in a custom var
  const getBaseBottom = (el) => {
    const existing = el.style.getPropertyValue('--fc-base-bottom');
    if (existing) return existing.trim();
    const b = getComputedStyle(el).bottom; // already resolved to px at runtime
    const base = isFinite(parseFloat(b)) ? `${parseFloat(b)}px` : '0px';
    el.style.setProperty('--fc-base-bottom', base);
    return base;
  };

  const measureHeight = (el) => Math.ceil(el.getBoundingClientRect().height || 0);

  /* ---------- core layout pass: stack + reserve ---------- */
  function layout() {
    const candidates = [...document.querySelectorAll(SEL)].filter(isVisible);

    // Sort: highest priority (data-sticky-priority) sits closest to the bottom.
    // Then by baseline bottom (smaller bottom → closer to the screen edge).
    candidates.sort((a,b) => {
      const pa = parseFloat(a.getAttribute('data-sticky-priority') || '0');
      const pb = parseFloat(b.getAttribute('data-sticky-priority') || '0');
      if (pb !== pa) return pb - pa;
      return parseFloat(getBaseBottom(a)) - parseFloat(getBaseBottom(b));
    });

    let offset = 0;
    const gap = GAP_PX();
    let bottomMostHeight = 0;

    candidates.forEach((el, idx) => {
      const base = getBaseBottom(el);
      const h    = measureHeight(el);

      // First (bottom-most) element stays at its baseline; others stack above it.
      el.style.setProperty('--fc-stack', px(idx === 0 ? 0 : offset + gap));
      el.style.bottom = `calc(var(--fc-base-bottom) + var(--fc-stack, 0px))`;
      el.classList.add('fc-sticky-managed');

      if (idx === 0) bottomMostHeight = h;
      if (idx === 0) offset = h; else offset += h + gap;
    });

    // Reserve space for the bottom-most CTA only (so content doesn't sit underneath)
    const reserved = bottomMostHeight;
    document.documentElement.style.setProperty('--fc-sticky-h', px(reserved));
    if (RESERVE) RESERVE.style.height = `calc(var(--fc-sticky-h,0px) + var(--fc-safe-bottom))`;
  }

  /* ---------- auto-hide near footer (opt-out with data-no-autohide) ---------- */
  function bindFooterAutohide() {
    const footer = document.getElementById('site-footer') || document.querySelector('[role="contentinfo"]');
    if (!footer || !('IntersectionObserver' in window)) return;

    const setHidden = (hide) => {
      document.querySelectorAll(SEL).forEach(el => {
        if (el.hasAttribute('data-no-autohide')) return; // opt-out
        el.classList.toggle('fc-sticky-hide', !!hide);
      });
    };

    const io = new IntersectionObserver(([entry]) => {
      setHidden(entry && entry.isIntersecting);
    }, { rootMargin: '0px 0px -8% 0px', threshold: 0.01 });

    io.observe(footer);
  }

  /* ---------- observers & events ---------- */
  let ro = null;
  const resizeWatch = () => {
    if (ro) ro.disconnect();
    ro = new ResizeObserver(() => rafLayout());
    document.querySelectorAll(SEL).forEach(el => ro.observe(el));
  };

  let mo = null;
  const mutationWatch = () => {
    if (mo) mo.disconnect();
    mo = new MutationObserver((muts) => {
      // If CTAs are added/removed/hidden, re-layout
      if (muts.some(m => m.type === 'childList' || (m.type === 'attributes' && (m.attributeName === 'class' || m.attributeName === 'style' || m.attributeName === 'hidden')))) {
        rafLayout();
      }
    });
    mo.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class','style','hidden'] });
  };

  let rafId = null;
  const rafLayout = () => { if (rafId) cancelAnimationFrame(rafId); rafId = requestAnimationFrame(layout); };

  addEventListener('resize', rafLayout, { passive:true });
  addEventListener('orientationchange', rafLayout);
  ['fc:donate:open','fc:donate:close','fc:sticky:measure'].forEach(ev => addEventListener(ev, rafLayout));

  // Initial run
  bindFooterAutohide();
  resizeWatch();
  mutationWatch();
  rafLayout();

  /* ---------- tiny public API ---------- */
  window.fcSticky = {
    measure: rafLayout,
    register(el){ if (!el) return; el.setAttribute('data-sticky-cta',''); rafLayout(); resizeWatch(); },
    unregister(el){ if (!el) return; el.removeAttribute('data-sticky-cta'); rafLayout(); resizeWatch(); }
  };
})();
{% if script_close is defined %}{{ script_close() }}{% else %}</script>{% endif %}

</section>
</section>
