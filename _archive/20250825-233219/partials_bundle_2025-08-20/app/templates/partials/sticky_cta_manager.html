{# ================= Sticky CTA Manager â€” reserves space + prevents overlap
(Elite) ================= #} {% include "partials/ui_bootstrap.html" ignore
missing with context %} {% set NONCE = NONCE if NONCE is defined else
(csp_nonce() if csp_nonce is defined else '') %}

<section
  data-ui="{{ (name|default('sticky_cta_manager'))|replace('_','-') }}"
  class="block"
>
  <h2 class="sr-only">Sticky CTA Manager</h2>

  <div id="fc-sticky-reserve" aria-hidden="true" style="height: 0"></div>

  <style nonce="{{ NONCE }}">
    :root {
      --fc-sticky-h: 0px; /* reserved height for bottom-most CTA */
      --fc-sticky-gap: 8px; /* vertical gap between stacked CTAs */
      --fc-safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    /* Reserve bottom padding so content doesn't sit under fixed CTAs */
    main,
    #main {
      padding-bottom: calc(var(--fc-sticky-h, 0px) + var(--fc-safe-bottom));
    }
    /* Utility: fade when hidden */
    .fc-sticky-hide {
      opacity: 0 !important;
      pointer-events: none !important;
      transform: translateY(6px);
    }
    /* Mark when manager is controlling an element */
    [data-sticky-cta].fc-sticky-managed {
      will-change: bottom, transform;
      transition: transform 0.18s ease;
    }
    @media (prefers-reduced-motion: reduce) {
      [data-sticky-cta].fc-sticky-managed {
        transition: none !important;
      }
    }
  </style>

  <script nonce="{{ NONCE }}">
    (() => {
      if (window.__fcStickyMgr) return;
      window.__fcStickyMgr = true;

      const RESERVE = document.getElementById("fc-sticky-reserve");
      const SEL = "[data-sticky-cta]";
      const GAP_PX = () =>
        parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--fc-sticky-gap",
          ),
        ) || 8;

      /* ---------- helpers ---------- */
      const isVisible = (el) => {
        if (!el || el.hidden) return false;
        const cs = getComputedStyle(el);
        if (
          cs.position !== "fixed" ||
          cs.display === "none" ||
          cs.visibility === "hidden"
        )
          return false;
        if (el.offsetParent === null) return false;
        return cs.bottom !== "auto"; // stack bottom-anchored CTAs only
      };

      const px = (v) => `${Math.max(0, Math.round(Number(v) || 0))}px`;

      // Get element's baseline bottom (px) before stacking; cache as CSS var
      const getBaseBottom = (el) => {
        const existing = el.style.getPropertyValue("--fc-base-bottom");
        if (existing) return existing.trim();
        const b = getComputedStyle(el).bottom;
        const base = isFinite(parseFloat(b)) ? `${parseFloat(b)}px` : "0px";
        el.style.setProperty("--fc-base-bottom", base);
        return base;
      };

      const measureHeight = (el) =>
        Math.ceil(el.getBoundingClientRect().height || 0);

      /* ---------- core layout pass: stack + reserve ---------- */
      function layout() {
        const candidates = [...document.querySelectorAll(SEL)].filter(
          isVisible,
        );

        // Sort: higher data-sticky-priority closer to the bottom; then by baseline bottom
        candidates.sort((a, b) => {
          const pa = parseFloat(a.getAttribute("data-sticky-priority") || "0");
          const pb = parseFloat(b.getAttribute("data-sticky-priority") || "0");
          if (pb !== pa) return pb - pa;
          return parseFloat(getBaseBottom(a)) - parseFloat(getBaseBottom(b));
        });

        let offset = 0;
        const gap = GAP_PX();
        let bottomMostHeight = 0;

        candidates.forEach((el, idx) => {
          const base = getBaseBottom(el); // eslint-disable-line no-unused-vars
          const h = measureHeight(el);

          // First (bottom-most) element stays at baseline; others stack above it.
          el.style.setProperty("--fc-stack", px(idx === 0 ? 0 : offset + gap));
          el.style.bottom = `calc(var(--fc-base-bottom) + var(--fc-stack, 0px))`;
          el.classList.add("fc-sticky-managed");

          if (idx === 0) bottomMostHeight = h;
          if (idx === 0) offset = h;
          else offset += h + gap;
        });

        // Reserve space for bottom-most CTA
        const reserved = bottomMostHeight;
        document.documentElement.style.setProperty(
          "--fc-sticky-h",
          px(reserved),
        );
        if (RESERVE)
          RESERVE.style.height = `calc(var(--fc-sticky-h,0px) + var(--fc-safe-bottom))`;
      }

      /* ---------- auto-hide near footer (opt-out with data-no-autohide) ---------- */
      function bindFooterAutohide() {
        const footer =
          document.getElementById("site-footer") ||
          document.querySelector('[role="contentinfo"]');
        if (!footer || !("IntersectionObserver" in window)) return;

        const setHidden = (hide) => {
          document.querySelectorAll(SEL).forEach((el) => {
            if (el.hasAttribute("data-no-autohide")) return; // opt-out
            el.classList.toggle("fc-sticky-hide", !!hide);
          });
        };

        const io = new IntersectionObserver(
          ([entry]) => {
            setHidden(entry && entry.isIntersecting);
          },
          { rootMargin: "0px 0px -8% 0px", threshold: 0.01 },
        );

        io.observe(footer);
      }

      /* ---------- observers & events ---------- */
      let ro = null;
      const resizeWatch = () => {
        if (ro) ro.disconnect();
        ro = new ResizeObserver(() => rafLayout());
        document.querySelectorAll(SEL).forEach((el) => ro.observe(el));
      };

      let mo = null;
      const mutationWatch = () => {
        if (mo) mo.disconnect();
        mo = new MutationObserver((muts) => {
          // If CTAs are added/removed/hidden, re-layout
          if (
            muts.some(
              (m) =>
                m.type === "childList" ||
                (m.type === "attributes" &&
                  (m.attributeName === "class" ||
                    m.attributeName === "style" ||
                    m.attributeName === "hidden")),
            )
          ) {
            rafLayout();
          }
        });
        mo.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "style", "hidden"],
        });
      };

      let rafId = null;
      const rafLayout = () => {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(layout);
      };

      addEventListener("resize", rafLayout, { passive: true });
      addEventListener("orientationchange", rafLayout);
      ["fc:donate:open", "fc:donate:close", "fc:sticky:measure"].forEach((ev) =>
        addEventListener(ev, rafLayout),
      );

      // Initial run
      bindFooterAutohide();
      resizeWatch();
      mutationWatch();
      rafLayout();

      /* ---------- public API ---------- */
      window.fcSticky = {
        measure: rafLayout,
        register(el) {
          if (!el) return;
          el.setAttribute("data-sticky-cta", "");
          rafLayout();
          resizeWatch();
        },
        unregister(el) {
          if (!el) return;
          el.removeAttribute("data-sticky-cta");
          rafLayout();
          resizeWatch();
        },
      };
    })();
  </script>
</section>
